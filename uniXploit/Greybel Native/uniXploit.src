Meta = include_lib("lib/metaxploit.so")
Crypto = include_lib("lib/crypto.so")
exploitReport = ""
Exploit = {}
Exploit.make = function(address, tag = "failure")
	if address isa list then
		tag = address[1]
		address = address[0]
	end if
	x = new self
	x.address = address
	x.tag = tag
	return x
end function

getLib = function(ip, port)
	net = Meta.net_use(ip, port)
	if not net then return ("net broken. pls fix it")
	metaLib = net.dump_lib
	return metaLib
end function

extractExploits = function(metaLib)
	libName = metaLib.lib_name
	libVersion = metaLib.version
	exploitReport = libName + " | Version:" + libVersion + char(10)
	startClock = time
	_memList = Meta.scan(metaLib)
	endClock = time
	TextLog.printLog("Library scanned in " + (endClock - startClock) + "s.")
	exploits = []
	for mem in _memList
		scan0 = Meta.scan_address(metaLib, mem)
		exploitReport = exploitReport + char(10) * 2 + "_" * 10 + char(10) + mem + char(10) + scan0
		report = scan0.split("Unsafe check: ")[1 : ]
		for exploit in report

			_start = (exploit.indexOf("<b>")) + 3
			_end = exploit.indexOf("</b>")
			tag = exploit[_start : _end]
			newExploit = Exploit.make(mem, tag)
			exploits.push(newExploit)
		end for
	end for
	generateReport(exploitReport, metaLib)
	return exploits
end function

listExploits_Mem = function(exploits)
	if not exploits isa list then return ("Error: it's not a list somehow. Fix it.")
	_memList = []
	for exploit in exploits
		_memList.push(exploit.address)
	end for
	_memList = _memList.clean
	return _memList
end function

listExploits_Tag = function(memSelect, exploits)
	vulnList = []

	for exploit in exploits
		if exploit.indexOf(memSelect) then vulnList.push(exploit.tag)
	end for
	return vulnList
end function

selectMem = function(memList)
	TextLog.clearLog
	TextLog.add("Vulnerable Addresses: ")
	x = 0
	for mem in memList
		TextLog.add("[" + str(x).color(255, 150, 50) + "] | " + mem.color(
			255,
			255,
			0,
			80,
			1))
		x = x + 1
	end for
	TextLog.printLog("Please choose an address (from index: " + str(0).color(255, 150, 50) + "-" + str(memList.len - 1).color(255, 150, 50) + ")")
	memSelect = ""
	while true
		select = to_int(user_input("Make a Selection: ".color(0, 255, 255)))
		if not memList.hasIndex(select) then
			TextLog.warnLog("Warning: Invalid Selection. Please try again.")
			continue
		end if
		memSelect = memList[select]
		break
	end while
	return memSelect
end function

selectTag = function(vulnList, memSelect)
	x = 0
	TextLog.clearLog
	TextLog.add("Vulnerable Strings:")
	for tag in vulnList
		TextLog.add("[" + str(x).color(0, 255, 0) + "]:[" + (address).color(255, 255, 50) + "] | " + (tag).color(
			0,
			255,
			255,
			80,
			1))
		x = x + 1
	end for
	TextLog.printLog
	while true
		choice = to_int(user_input("Make a Selection: ".color(0, 255, 255)))
		if not choice isa number then
			TextLog.warnLog("Warning: Invalid Selection. Please try again.")
			continue
		end if
		attack = Exploit.make(memSelect, vulnList[choice])
		break
	end while
	return attack
end function

getRootFolder = function(obj)
	if typeof(obj) == "shell" then return obj.host_computer.File("/")
	if typeof(obj) == "computer" then return obj.File("/")
	if typeof(obj) == "file" then
		while true
			if obj.name != "/" then
				obj = obj.parent
			else
				return obj
			end if
		end while
	end if
end function

getPasswd = function(obj)
	rootFolder = getRootFolder(obj)
	for folder in rootFolder.get_folders
		if folder.name != "etc" then continue
		for file in folder.get_files
			if file.name != "passwd" then continue
			if not file.has_permission("r") then return 
			passwd = file.get_content
			return passwd
		end for
	end for
end function

crackPasswd = function(obj)
	deciphered = ""
	passwd = getPasswd(obj)
	if not passwd then return 
	passList = passwd.split(char(10))
	passList.remove(-1)
	Timer.waitSec(1)
	TextLog.clearLog
	Timer.waitSec(0.5)
	TextLog.printLog("passwd breached! Users: [" + str(passList.len).color(255, 255, 0) + "]")
	for pass in passList
		user = getUser(pass)
		TextLog.printLog(user)
		passHash = getHash(pass)
		startClock = time
		decipheredHash = Crypto.decipher(passHash)
		stopClock = time
		TextLog.printLog("deciphered in " + (stopClock - startClock) + "s.")
		deciphered = deciphered + user + ":" + decipheredHash
		if __pass_idx != passList.len - 1 then deciphered = deciphered + char(10)
	end for
	return deciphered
end function

getUser = function(stri)
	user = stri.split(":")[0]
	return user
end function

getHash = function(stri)
	passHash = stri.split(":")[1]
	return passHash
end function

savePasswd = function(passwd, ip)
	endResult = "[" + ip + "]" + char(10) + passwd
	destFolder = home + "/Reports"
	destFile = destFolder + "/" + ip + "_passwd.txt"
	if not checkReportFolder then return 
	if not computer.File(destFolder + "/" + ip + "_passwd.txt") then computer.touch(destFolder, ip + "_passwd.txt")
	endFile = computer.File(destFile)
	if not endFile then return 
	endFile.set_content(endResult)
	return 1
end function

getShell = function(obj)
	if typeof(obj) == "shell" then return obj
	return 
end function

checkReportFolder = function
	destFolder = home + "/Reports"
	if not computer.File(destFolder) then
		res = computer.create_folder(home, "Reports")
	else
		res = 1
	end if
	if res then return 1
	return 
end function

checkReportLibsFolder = function
	destFolder = home + "/Reports/Libs"
	if not computer.File(destFolder) then
		res = computer.create_folder(home + "/Reports", "Libs")
	else
		res = 1
	end if
	if res then return 1
	return 
end function

generateReport = function(expReport, metaLib)
	if not checkReportFolder then return 
	if not checkReportLibsFolder then return 
	destFolder = home + "/Reports/Libs"
	fileName = metaLib.lib_name + "_" + metaLib.version
	destFile = destFolder + "/" + fileName
	if not computer.File(destFile) then computer.touch(destFolder, fileName)
	res = computer.File(destFile).set_content(expReport)
	if res then
		TextLog.printLog("Library Exploit Report available in " + destFolder.color(0, 150, 255) + " as " + fileName.color(0, 150, 255))
		Timer.waitSec(3)
		return 1
	end if
	return 0
end function

// /Generic Globals

shell = get_shell
computer = shell.host_computer
home = home_dir
myIP = get_router.public_ip

// /Time utils

Timer = {}
Timer.waitSec = function(sec, style = 0)
	if style == 0 then
		d = 0
		while sec > 0
			TextLog.printLogRepeat("/////".rotate(d).color(255, 255, 0) + sec + "s")
			d = d + 3
			sec = sec - 0.1
			wait(0.1)
		end while
	end if
end function

// /TextLog utils

TextLog = {}

TextLog.Log = []

TextLog.currentLimit = 10

TextLog.clearLog = function
	self.Log.empty
end function

TextLog.add = function(entry)
	self.Log.push(entry)
	if self.Log.len > self.currentLimit then self.Log.remove(0)
end function

TextLog.printLog = function(entry)
	if entry then self.add(entry)
	print(self.Log.join(char(10)), 1)
end function

TextLog.printLogRepeat = function(entry)
	if not entry then print(self.Log.join(char(10)), 1)
	print(self.Log.join(char(10)) + char(10) + entry, 1)
end function

TextLog.warnLog = function(warning)
	print(self.Log.join(char(10)) + char(10) + warning.color(255, 0, 100), 1)
end function



// /List utils

list.empty = function
	_list = self
	while _list.len > 0
		_list.remove(0)
	end while
end function

list.clean = function
	set = []
	_list = self
	for item in _list
		if set.indexOf(item) == null then set.push(item)
	end for
	_list.empty
	for item in set
		_list.push(item)
	end for
	return _list
end function



// /String utils

string.align = function(alignment)
	if not (alignment == "left" or alignment == "right" or alignment == "center" or alignment == "justified" or alignment == "flush") then return self
	return ("<align=""" + alignment + """>" + self + "</align>")
end function
string.altFont = function
	return ("<font=""LiberationSans SDF"">" + self + "</font>")
end function
string.case = function(case)
	if not (case == "uppercase" or case == "lowercase" or case == "allcaps" or case == "smallcaps") then return self
	return ("<" + case + ">" + self + "</" + case + ">")
end function
string.format = function(format)
	if not (format == "i" or format == "b" or format == "u" or format == "s" or format == "sub" or format == "sup") then return self
	return ("<" + format + ">" + self + "</" + format + ">")
end function
string.cspace = function(cspace)
	if not cspace isa number then return self
	return ("<cspace=+" + cspace + "em>" + self + "</cspace>")
end function
string.indent = function(percent, line = 0)
	if not percent isa number then return self
	percent = clamp(percent, 0, 100)
	if not line then return ("<indent=" + percent + "%>" + self + "</indent>")
	return ("<line-indent=" + percent + "%>" + self + "</line-indent>")
end function
string.alpha = function(alpha)
	if not alpha isa number then return self
	alphaHex = alpha_to_hex(alpha)
	return ("<alpha=" + alphaHex + ">" + self + "<alpha=#FF>")
end function
string.color = function(r, g, b, a = 255, mark = 0)
	if not (r isa number and g isa number and b isa number and a isa number) then return self
	colorHex = rgb_to_hex(
		r,
		g,
		b,
		a)
	if mark then return ("<mark=" + colorHex + ">" + self + "</mark>")
	return ("<color=" + colorHex + ">" + self + "</color>")
end function
string.margin = function(percent, side = "")
	if not (percent isa number and side isa string) then return self
	if not (side == "left" or side == "right" or side == "") then return self
	percent = clamp(percent, 0, 100)
	if side == "left" or side == "right" then return ("<margin-" + side + "=" + percent + "%>" + self + "</margin>")
	return ("<margin=" + percent + "%>" + self + "</margin>")
end function
string.mspace = function(spacing)
	if not spacing isa number then return self
	return ("<mspace=" + spacing + "em>" + self + "</mspace>")
end function
string.nobr = function
	return ("<nobr>" + self + "</nobr>")
end function
string.pos = function(percent)
	if not percent isa number then return self
	percent = clamp(percent, 0, 100)
	return ("<pos=" + percent + "%>" + self)
end function
string.rotate = function(degree)
	if not degree isa number then return self
	degree = clamp(degree, -180, 180)
	return ("<rotate=""" + degree + """>" + self + "</rotate>")
end function
string.csize = function(percent)
	if not percent isa number then return self
	return ("<size=" + percent + "%>" + self + "</size>")
end function
string.space = function(space)
	if not space isa number then return self
	return ("<space=" + space + "em>" + self)
end function
string.voffset = function(offset)
	if not offset isa number then return self
	return ("<voffset=" + offset + "em>" + self + "</voffset>")
end function
string.width = function(percent)
	if not percent isa number then return self
	percent = clamp(percent, 0, 100)
	return ("<width=" + percent + "%>" + self + "</width>")
end function

// /Number/math utils

max = function(a, b)
	if a > b then return a
	return b
end function

min = function(a, b)
	if a < b then return a
	return b
end function

clamp = function(num, lowClamp = 0, highClamp)
	if not highClamp then
		if num < lowClamp then return lowClamp
	end if
	return max(min(num, highClamp), lowClamp)
end function

_hexNibble = function(v)
	if v < 10 then return char(48 + v)
	return char(55 + v)
end function

_toHexByte = function(n)
	num = clamp(n, 0, 255)
	hi = floor(num / 16)
	lo = num - hi * 16
	return (_hexNibble(hi) + _hexNibble(lo))
end function

rgb_to_hex = function(r, g, b, a)
	return ("#" + _toHexByte(r) + _toHexByte(g) + _toHexByte(b) + _toHexByte(a))
end function



// /File utils


makeFile = function(folderPath, fileName)
	filePath = home + "/" + folderPath
	file = computer.File(filePath + "/" + fileName)
	if file then return ("File already exists.")
	file = computer.File(folderPath)
	if not file then
		resFolder = computer.create_folder(home, folderPath)
		if resFolder isa number then print("created folder at " + folderPath) else return (resFolder)
	end if
	resFile = computer.touch(filePath, fileName)
	if resFile isa string then return (resFile)
	return (1)
end function

writeFile = function(filePath, content)
	file = computer.File(filePath)
	if not file then return ("Could not write to file.")
	res = file.set_content(content)
	return (res)
end function


openPorts = function(ip)
	router = get_router(ip)
	ports = [ 0 ]
	for port in router.used_ports
		if not port.is_closed then ports.push(port.port_number)
	end for
	return ports
end function

portSelect = function(ports)
	x = 0
	TextLog.add("Open ports at " + ip.color(255, 255, 0))
	for port in ports
		TextLog.add("[" + str(x).color(255, 0, 50) + "] " + port)
		x = x + 1
	end for
	TextLog.printLog
	while true
		sel = to_int(user_input("Please choose port (from index): "))
		if ports.hasIndex(sel) then break
		TextLog.warnLog(sel.color(255, 0, 0) + " is not a valid selection. Please select an index between 0 and ".color(0, 255, 255) + str(ports.len - 1).color(0, 255, 255))
	end while
	return (ports[sel])
end function


port = null
ip = null
target = null
targetList = [
	"shell",
	"passwd",
]
if params.len >= 1 then
	ip = params[0]
	if params.len > 1 then target = params[1]
end if

if not (ip and is_valid_ip(ip)) then
	while true
		ip = user_input("Enter IP Address: ")
		if is_valid_ip(ip) then break
		print("Invalid IP.".color(255, 0, 0))
	end while
end if

if target != "firewall" then
	ports = openPorts(ip)
	port = portSelect(ports)
else
	port = 0
end if
x = 0
if not target then
	TextLog.clearLog
	for trgt in targetList
		TextLog.add("[" + x + "] " + trgt)
		x = x + 1
	end for
	while true
		TextLog.printLog
		target = user_input("Choose a method: ").to_int
		if targetList.hasIndex(target) then
			target = targetList[target]
			break
		end if
		TextLog.warnLog("WARNING: Choice out of index.")
	end while
end if

metaLib = getLib(ip, port)
exploits = extractExploits(metaLib)

memList = listExploits_Mem(exploits)

address = selectMem(memList)

vulnList = listExploits_Tag(address, exploits)

attack = selectTag(vulnList, address)
fail = null
while true
	result = null
	while true
		if not fail then
			result = metaLib.overflow(attack.address, attack.tag)
			TextLog.clearLog
		end if
		fail = null
		if not result then
			TextLog.warnLog("The previous attack failed.")
			choice = user_input("Type ""m"" to restart from Memory Select. Type ""v"" to restart from Vulnerability Select. Anything else to exit.", 0, 1)
			if choice == "m" then
				address = selectMem(memList)
				vulnList = listExploits_Tag(address, exploits)
				attack = selectTag(vulnList, address)
			else if choice == "v" then
				attack = selectTag(vulnList, address)
			else
				exit("exiting...")
			end if
			continue
		end if
		break
	end while

	if target == "passwd" then
		decipheredPasswd = crackPasswd(result)
		if not decipheredPasswd then
			TextLog.warnLog("WARNING: Could not crack passwd file. No read permission for current privilege level.")
			Timer.waitSec(3)
			fail = 1
			continue
		end if
		saveOK = savePasswd(decipheredPasswd, ip)
		if saveOK then
			TextLog.clearLog
			TextLog.printLog("Success!!".color(0, 255, 0))
			TextLog.printLog("Passwd report saved in " + (home + "/Reports/ as " + ip + "_passwd.txt").color(0, 150, 255))
		else
			TextLog.clearLog
			TextLog.warnLog("WARNINIG: failed to save file at " + home + "/Reports/ as " + ip + "_passwd.txt")
		end if
		Timer.waitSec(3)
		exit("Program End")
	else if target == "shell" then
		// shell stuff
		if not getShell(result) then
			TextLog.warnLog("WARNING: Not a shell object.")
			Timer.waitSec(3)
			fail = 1
			continue
		else
			result.start_terminal
			break
		end if
	end if
	break
end while

